<!DOCTYPE html>
<meta charset="utf-8">
<title>WebGL - #01</title>
<script src="lib/underscore.min.js"></script>
<script src="lib/jquery.min.js"></script>
<!-- gl-matrix documentation: http://glmatrix.net/docs/2.2.0/ -->
<script src="lib/gl-matrix.js"></script>
<link href="site.css" rel="stylesheet" type="text/css" />

<!-- development link: http://ghkl/webgl/01-simple_shapes_2d.html -->

<body>
  <h3 class="document-title"></h3>
  <canvas width="600" height="400"></canvas>
</body>

<!-- Thanks to MDN at https://developer.mozilla.org/en-US/docs/Web/WebGL/Adding_2D_content_to_a_WebGL_context -->
<script id="shader-fs" type="x-shader/x-fragment">
  //precision mediump float;
  // gl_FragColor is a built-in GL variable that is used for the fragment's color.
  // Setting its value establishes the pixel's color, as seen below.
  void main(void) {
    gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
  }
</script>

<script id="shader-vs" type="x-shader/x-vertex">
  attribute vec3 vertexPosition;
  uniform mat4 modelViewMatrix;
  uniform mat4 perspectiveMatrix;

  void main(void) {
    gl_Position = perspectiveMatrix * modelViewMatrix * vec4(vertexPosition, 1.0);
  }
</script>

<script>
var triangle_vertices = [
   0.0,  1.0,  0.0,
  -1.0, -1.0,  0.0,
   1.0, -1.0,  0.0,
];

var square_vertices = [
   1.0,  1.0,  0.0,
  -1.0,  1.0,  0.0,
   1.0, -1.0,  0.0,
  -1.0, -1.0,  0.0,
];

function draw(gl) {
  var program = getShaderProgram(gl, ['#shader-vs', '#shader-fs'])

  // not sure; factor shaders into stateful perspective and move matrices?
  var vertexPosition_location = gl.getAttribLocation(program, 'vertexPosition');
  // gl.getUniformLocation() is saying "get the address of this variable so we can set it later",
  // but we have to specify the type of the variable (a uniform)
  var perspectiveMatrix_location = gl.getUniformLocation(program, 'perspectiveMatrix');
  var modelViewMatrix_location = gl.getUniformLocation(program, 'modelViewMatrix');

  var perspective = mat4.perspective(mat4.create(), // out
    Math.PI / 4, // fovy
    gl.canvas.width / gl.canvas.height, // aspect
    0.1, // near
    100.0); // far
  // each vertex is three values, thus the 3 below.
  gl.uniformMatrix4fv(perspectiveMatrix_location, false, perspective);


  var triangle_buffer = createBuffer3D(gl, triangle_vertices);
  var square_buffer = createBuffer3D(gl, square_vertices);

  // draw!

  // Clear the color as well as the depth buffer.
  gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

  // reset our MVMatrix, in case we are redrawing.
  var modelView = mat4.create();
  mat4.identity(modelView);

  // actually draw things...

  // 1. make the triangle
  // 1a. move
  mat4.translate(modelView, modelView, [-1.5, 0.0, -7.0]);
  gl.uniformMatrix4fv(modelViewMatrix_location, false, modelView);

  // 1b. draw from the loaded buffer
  // point to the buffer we're going to be drawing
  gl.bindBuffer(gl.ARRAY_BUFFER, triangle_buffer);
  // enableVertexAttribArray tells webgl we are going to supply data from a buffer,
  //   into the variable at vertexPosition_location
  gl.enableVertexAttribArray(vertexPosition_location);
  gl.vertexAttribPointer(
    vertexPosition_location, // location
    3, // numComponents
    gl.FLOAT, // typeOfData
    false, // normalizeFlag
    0, // strideToNextPieceOfData
    0); // offsetIntoBuffer
  gl.drawArrays(gl.TRIANGLES, // mode
    0, // where to start
    3); // how many (vertices length / 3)

  // 2. make the square
  // 2a. move
  mat4.translate(modelView, modelView, [3.0, 0.0, 0.0]);
  gl.bindBuffer(gl.ARRAY_BUFFER, square_buffer);
  // vertexAttribPointer has to be called after every bindBuffer
  gl.vertexAttribPointer(vertexPosition_location, 3, gl.FLOAT, false, 0, 0);
  // enableVertexAttribArray doesn't, but it's more proper to do so.
  gl.enableVertexAttribArray(vertexPosition_location);
  gl.uniformMatrix4fv(modelViewMatrix_location, false, modelView);
  // 2b. draw
  gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
}

document.addEventListener('glready', function(ev) {
  // glready's Event.detail is a webgl context
  draw(ev.detail);
});

document.querySelector('h3').innerText = document.title;
// document.addEventListener('domready', function(ev) {});

</script>
<!-- gl-helpers makes sure that the readystatechange -> canvasready -> glready event chain is kicked off  -->
<script src="gl-helpers.js"></script>
